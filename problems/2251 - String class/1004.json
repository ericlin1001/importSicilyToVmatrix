{"ptype_id": 0, "description": "# Description\n<p>Given a dictionary of words, and then a sentence, break the sentence in to words separated by blank spaces.<br />\r\nIf more than one words in the dictionary matches the input, use the longest word. As in the example below, if both &quot;student&quot; and &quot;students&quot; match, we will use &quot;students&quot;, the longer word.<br />\r\nIf no word in the dictionary matches, output each single character as a word. As in the example below, &quot;sysu&quot; is output as &quot;s y s u&quot;.</p>\n# Input\n<p>An integer N representing the number of words in the dictionary.<br />\r\nN lines, each of which is a words in the dictionary.<br />\r\nA final line containing the sentence to be broken into words.<br />\r\nThe dictionary contains less than 1000 words.<br />\r\nThe words in the dictionary contains less than 10000 characters in total.<br />\r\nThe sentence contains less than 1000 characters.</p>\n# Output\n<p>&nbsp;A line with its words separated by one blank space. There is no blank after the last word.</p>\n# Sample_Input\n```\n6\r\nthe\r\nthey\r\nstudent\r\nstudents\r\nare\r\narea\r\ntheyaresysustudents\n```\n# Sample_Ouput\n```\nthey are s y s u students\n```\n# Hint\n\n", "title": "From Sicily::2251 - String class::1004::Break words", "files": {"hidden_support": {}, "submission": {"source.cpp": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint N, minLen = 10010, maxLen = 0;\nstring words[1010];\nstring result[1010];\nint r_count = 0;\n\nbool find(string str) {\n\tfor (int i = 0; i < N; i++) {\n\t\tif (words[i] == str) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> words[i];\n\t\tif (words[i].length() < minLen) {\n\t\t\tminLen = words[i].length();\n\t\t}\n\t\tif (words[i].length() > maxLen) {\n\t\t\tmaxLen = words[i].length();\n\t\t}\n\t}\n\tstring sentence;\n\tcin >> sentence;\n\tint start = 0;\n\n\twhile (start < sentence.length()) {\n\t\tint len = 1;\n\t\tfor (int i = maxLen; i >= minLen; i--) {\n\t\t\tstring sub = sentence.substr(start, i);\n\t\t\tif (find(sub)) {\n\t\t\t\tlen = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult[r_count] = sentence.substr(start, len);\n\t\tstart += len;\n\t\tr_count += 1;\n\t}\n\n\tif (r_count > 0) {\n\t\tcout << result[0];\n\t}\n\tfor (int i = 1; i < r_count; i++) {\n\t\tcout << ' ' << result[i];\n\t}\n\tcout << endl;\n\treturn 0;\n}\n\n"}, "standard_output": {"standard_output0": "qwerty 1 2 3 zxcvb asdfgh 9 8 7 asdfg zxc qwert\n"}, "support": {}, "random_source": {}, "standard_input": {"standard_input0": "12\nqwe\nqwert\nqwerty\nqwertyu\nasd\nasdfg\nasdfgh\nasdfghj\nzx\nzxc\nzxcvb\nzxcvbnm\nqwerty123zxcvbasdfgh987asdfgzxcqwert\n\n"}}, "config": {"limits": {"time": 1000, "memory": 32}, "standard_language": "c++", "grading": {"memory check": 0, "compile check": 10, "random tests": 0, "static check": 20, "google tests": 0, "standard tests": 70, "google tests detail": {}}, "submission": ["source.cpp"], "standard": {"hidden_support": [], "standard_input": ["standard_input0"], "support": [], "random_source": [], "standard_output": ["standard_output0"]}, "google tests info": {}, "random": {"compile_command": "gcc SOURCE -w -std=c++14 -o random", "run_times": 0}, "language": ["c++"], "standard_score": 100, "exec_flag": "--gtest_output=xml:/tmp/Result.xml", "output_program": "main.exe", "compilers": {"c": {"command": "gcc CODE_FILES -g -w -lm -o OUTPUT_PROGRAM", "version": "default"}, "clang++": {"command": "clang++ CODE_FILES -g -w -lm -std=c++11 -o OUTPUT_PROGRAM", "version": "default"}, "c++": {"command": "g++ CODE_FILES -g -w -lm -std=c++14 -o OUTPUT_PROGRAM", "version": "default"}, "clang": {"command": "clang CODE_FILES -g -w -lm -o OUTPUT_PROGRAM", "version": "default"}}, "entry_point": "standard_main.exe"}}